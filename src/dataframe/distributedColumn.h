//lang: CwC
#pragma once
#include "../utils/string.h"
#include "../utils/array.h"
#include "../utils/distributedArray.h"
#include "../store/kvstore.h"
#include "../serialize/deserialize.h"
#include "../serialize/jsonHelper.h"
#include "column.h"
#include<stdarg.h>
#include<stdio.h>

//Authors: Shetty.y@husky.neu.edu eldrid.s@husky.neu.edu

/*************************************************************************
 * DistrbutedIntColumn::
 * Holds int values.
 */
class DistrbutedIntColumn : public Column {
 public:
  KVStore* kv_;
  size_t chunkSize_;
  size_t uid_;
  IntDistributedArray* val_;

  DistrbutedIntColumn(KVStore* kv, size_t chunkSize, size_t uid) {
      this->kv_ = kv;
      this->chunkSize_ = chunkSize;
      this->uid_ = uid;
      this->val_ = new IntDistributedArray(kv, chunkSize, uid);
  };


  // DistrbutedIntColumn(char* serialized) {
  //   char* payload = JSONHelper::getPayloadValue(serialized)->c_str();
  //   this->arraySize_ = std::stoi(JSONHelper::getValueFromKey("arraySize_", payload)->c_str());
  //   this->listLength_ = std::stoi(JSONHelper::getValueFromKey("listLength_", payload)->c_str());
  //   this->val_ = new Array(JSONHelper::getValueFromKey("val_", payload)->c_str());
  // }

  ~DistrbutedIntColumn() {
   // delete val_;
  }

  /** get int value at idx. An out of bound idx triggers an assert error.  */
  int get(size_t idx) {
    return this->val_->get(idx);
  };

  /** Set value at idx. An out of bound idx triggers an assert error.  */
  void set(size_t idx, int val) {
    this->val_->set(idx, val);
  };
  /** returns length of int column */
  size_t size() { return this->val_->length(); };
 
  /** Type appropriate push_back methods. Calling the wrong method results
    * in no data change. **/
  void push_back(int val) {
    this->val_->pushBack(val);
  };
  void push_back(double val) {};
  void push_back(bool val) {};
  void push_back(float val) {};
  void push_back(String* val) {};
 
  /** Return the type of this column as a char: 'S', 'B', 'I' and 'F'.*/
  char get_type() { return 'I'; };

  /** returns a hash generated by summing all the elements together */
  size_t hash_me() {
    return this->val_->hash_me();
  }

  bool equals(Object * o) {
    if(o == nullptr) return false;
    DistrbutedIntColumn* other_ic = dynamic_cast<DistrbutedIntColumn*>(o);
    if(other_ic == nullptr) return false;
    if(other_ic->size() != size()) return false;
    IntDistributedArray* other_val_ = dynamic_cast<IntDistributedArray*>(other_ic->val_);
    return this->val_->equals(other_val_);
  }

  // char* serialize() {
  //   Serializable* sb = new Serializable();
  //   sb->initSerialize("DistrbutedIntColumn");
  //   sb->write("listLength_", listLength_);
  //   sb->write("arraySize_", arraySize_);
  //   sb->write("metaArrayStartSize__", metaArrayStartSize_);
  //   char * seralizedArr = val_->serialize();
  //   sb->write("val_", seralizedArr, false);
  //   sb->endSerialize();
  //   char* value = sb->get();
  //   delete sb;
  //   return value;
  // }
};
/*************************************************************************
 * DistrbutedDoubleColumn::
 * Holds double values.
 */
class DistrbutedDoubleColumn : public Column {
 public:
  KVStore* kv_;
  size_t chunkSize_;
  size_t uid_;
  DoubleDistributedArray* val_;

  DistrbutedDoubleColumn(KVStore* kv, size_t chunkSize, size_t uid) {
    this->kv_ = kv;
    this->chunkSize_ = chunkSize;
    this->uid_ = uid;
    this->val_ = new DoubleDistributedArray(kv, chunkSize, uid);
  };

  ~DistrbutedDoubleColumn() {
   // delete val_;
  }

  /** get double value at idx. An out of bound idx triggers an assert error.  */
  double get(size_t idx) {
    return this->val_->get(idx);
  };
  /** Set value at idx. An out of bound idx triggers an assert error.  */
  void set(size_t idx, double val) {
    this->val_->set(idx, val);
  };
  /** returns length of int column */
  size_t size() { return this->val_->length(); };
 
  /** Type appropriate push_back methods. Calling the wrong method results
    * in no data change. **/
  void push_back(double val) {
    this->val_->pushBack(val);
  };
  void push_back(int val) {};
  void push_back(bool val) {};
  void push_back(float val) {};
  void push_back(String* val) {};
 
  /** Return the type of this column as a char: 'S', 'B', 'I', 'D' and 'F'.*/
  char get_type() { return 'D'; };

  /** returns a hash generated by summing all the elements together */
  size_t hash_me() {
    return this->val_->hash_me();
  }

  bool equals(Object * o) {
    if(o == nullptr) return false;
    DistrbutedDoubleColumn* other_ic = dynamic_cast<DistrbutedDoubleColumn*>(o);
    if(other_ic == nullptr) return false;
    if(other_ic->size() != size()) return false;
    DoubleDistributedArray* other_val_ = dynamic_cast<DoubleDistributedArray*>(other_ic->val_);
    return this->val_->equals(other_val_);
  }

  // char* serialize() {
  //   Serializable* sb = new Serializable();
  //   sb->initSerialize("DistrbutedDoubleColumn");
  //   sb->write("listLength_", listLength_);
  //   sb->write("arraySize_", arraySize_);
  //   sb->write("metaArrayStartSize__", metaArrayStartSize_);
  //   char * seralizedArr = val_->serialize();
  //   sb->write("val_", seralizedArr, false);
  //   sb->endSerialize();
  //   char* value = sb->get();
  //   delete sb;
  //   return value;
  // }

  // static DistrbutedDoubleColumn* deserialize(char* s) {
  //   size_t arraySize = std::stoi(JSONHelper::getValueFromKey("arraySize_", s)->c_str());
  //   size_t listLength = std::stoi(JSONHelper::getValueFromKey("listLength_", s)->c_str());
  //   String* arr_string = JSONHelper::getValueFromKey("val_", s);
  //   char* arr_cstr = arr_string->c_str();
  //   Array* arr = new Array(arr_cstr);
  //   DistrbutedDoubleColumn* dc = new DistrbutedDoubleColumn(arr, listLength);
  //   return dc;
  // }
};
/*************************************************************************
 * DistrbutedFloatColumn::
 * Holds float values.
 */
class DistrbutedFloatColumn : public Column {
 public:
  KVStore* kv_;
  size_t chunkSize_;
  size_t uid_;
  FloatDistributedArray* val_;

  DistrbutedFloatColumn(KVStore* kv, size_t chunkSize, size_t uid) {
    this->kv_ = kv;
    this->chunkSize_ = chunkSize;
    this->uid_ = uid;
    this->val_ = new FloatDistributedArray(kv, chunkSize, uid);
  };

  ~DistrbutedFloatColumn() {
   // delete val_;
  }

  /** get value at idx. An out of bound idx triggers an assert error.  */
  float get(size_t idx) {
    return this->val_->get(idx);
  };

  /** Set value at idx. An out of bound idx triggers an assert error.  */
  void set(size_t idx, float val) {
   this->val_->set(idx, val);
  };
  /** returns length of column */
  size_t size() { return this->val_->length(); };

 
  /** Type appropriate push_back methods. Calling the wrong method results 
    * in no data change. **/
  void push_back(float val) {
    this->val_->pushBack(val);
  };
  void push_back(double val) {};
  void push_back(bool val) {};
  void push_back(int val) {};
  void push_back(String* val) {};
 
/** returns a hash created by summing int representations of the float values */
  size_t hash_me() {
   return this->val_->hash_me();
  }

  bool equals(Object * o) {
    if(o == nullptr) return false;
    DistrbutedFloatColumn* other_ic = dynamic_cast<DistrbutedFloatColumn*>(o);
    if(other_ic == nullptr) return false;
    if(other_ic->size() != size()) return false;
    FloatDistributedArray* other_val_ = dynamic_cast<FloatDistributedArray*>(other_ic->val_);
    return this->val_->equals(other_val_);
  }

  /** Return the type of this column as a char: 'S', 'B', 'I' and 'F'.*/
  char get_type() { return 'F'; };

  // char* serialize() {
  //   Serializable* sb = new Serializable();
  //   sb->initSerialize("DistrbutedFloatColumn");
  //   sb->write("listLength_", listLength_);
  //   sb->write("arraySize_", arraySize_);
  //   sb->write("metaArrayStartSize__", metaArrayStartSize_);
  //   char * seralizedArr = val_->serialize();
  //   sb->write("val_", seralizedArr, false);
  //   sb->endSerialize();
  //   char* value = sb->get();
  //   delete sb;
  //   return value;
  // }

  // static DistrbutedFloatColumn* deserialize(char* s) {
  //   size_t arraySize = std::stoi(JSONHelper::getValueFromKey("arraySize_", s)->c_str());
  //   size_t listLength = std::stoi(JSONHelper::getValueFromKey("listLength_", s)->c_str());
  //   String* arr_string = JSONHelper::getValueFromKey("val_", s);
  //   char* arr_cstr = arr_string->c_str();
  //   Array* arr = new Array(arr_cstr);
  //   DistrbutedFloatColumn* fc = new DistrbutedFloatColumn(arr, listLength);
  //   return fc;
  // }
};
/*************************************************************************
 * DistrbutedBoolColumn::
 * Holds bool values.
 */
class DistrbutedBoolColumn : public Column {
 public:
  KVStore* kv_;
  size_t chunkSize_;
  size_t uid_;
  BoolDistributedArray* val_;

  DistrbutedBoolColumn(KVStore* kv, size_t chunkSize, size_t uid) {
    this->kv_ = kv;
    this->chunkSize_ = chunkSize;
    this->uid_ = uid;
    this->val_ = new BoolDistributedArray(kv, chunkSize, uid);
  };

  ~DistrbutedBoolColumn() {
   // delete val_;  
  }

  /** get value at idx. An out of bound idx triggers an assert error.  */
  bool get(size_t idx) {
    return this->val_->get(idx);
  };

  /** Set value at idx. An out of bound idx triggers an assert error. */
  void set(size_t idx, bool val) {
    this->val_->set(idx, val);
  };
  /** returns the length of DistrbutedBoolColumn */
  size_t size() { return this->val_->length(); };
 
  /** Type appropriate push_back methods. Calling the wrong method results in
    * no data change. **/
  void push_back(bool val) {
    this->val_->pushBack(val);
  };
  void push_back(double val) {};
  void push_back(float val) {};
  void push_back(int val) {};
  void push_back(String* val) {};
 /** returns a hash of the values created by adding position and value of bool to hash */
  size_t hash_me() {
    return this->val_->hash_me();
  }

  bool equals(Object * o) {
    if(o == nullptr) return false;
    DistrbutedBoolColumn* other_ic = dynamic_cast<DistrbutedBoolColumn*>(o);
    if(other_ic == nullptr) return false;
    if(other_ic->size() != size()) return false;
    BoolDistributedArray* other_val_ = dynamic_cast<BoolDistributedArray*>(other_ic->val_);
    return this->val_->equals(other_val_);
  }

  /** Return the type of this column as a char: 'S', 'B', 'I' and 'F'.*/
  char get_type() { return 'B'; };

  // char* serialize() {
  //   Serializable* sb = new Serializable();
  //   sb->initSerialize("DistrbutedBoolColumn");
  //   sb->write("listLength_", listLength_);
  //   sb->write("arraySize_", arraySize_);
  //   sb->write("metaArrayStartSize__", metaArrayStartSize_);
  //   char * seralizedArr = val_->serialize();
  //   sb->write("val_", seralizedArr, false);
  //   sb->endSerialize();
  //   char* value = sb->get();
  //   delete sb;
  //   return value;
  // }

  // static DistrbutedBoolColumn* deserialize(char* s) {
  //   size_t arraySize = std::stoi(JSONHelper::getValueFromKey("arraySize_", s)->c_str());
  //   size_t listLength = std::stoi(JSONHelper::getValueFromKey("listLength_", s)->c_str());
  //   String* arr_string = JSONHelper::getValueFromKey("val_", s);
  //   char* arr_cstr = arr_string->c_str();
  //   Array* arr = new Array(arr_cstr);
  //   DistrbutedBoolColumn* bc = new DistrbutedBoolColumn(arr, listLength);
  //   return bc;
  // }
};
/*************************************************************************
 * DistrbutedStringColumn::
 * Holds bool values.
 */
class DistrbutedStringColumn : public Column {
 public:
  KVStore* kv_;
  size_t chunkSize_;
  size_t uid_;
  StringDistributedArray* val_;

  DistrbutedStringColumn(KVStore* kv, size_t chunkSize, size_t uid) {
    this->kv_ = kv;
    this->chunkSize_ = chunkSize;
    this->uid_ = uid;
    this->val_ = new StringDistributedArray(kv, chunkSize, uid);

  };

  // DistrbutedStringColumn(char* serialized) {
  //   char* payload = JSONHelper::getPayloadValue(serialized)->c_str();
  //   this->arraySize_ = std::stoi(JSONHelper::getValueFromKey("arraySize_", payload)->c_str());
  //   this->listLength_ = std::stoi(JSONHelper::getValueFromKey("listLength_", payload)->c_str());
  //   this->val_ = new Array(JSONHelper::getValueFromKey("val_", payload)->c_str());
  // }

  ~DistrbutedStringColumn() {
   // delete val_;
  }

/** Get pointer at idx. An out of bound idx triggers an assert error. */
  String* get(size_t idx) {
    return this->val_->get(idx);
  };
  /** Set pointer at idx. An out of bound idx is undefined.  */
  void set(size_t idx, String* val) {
    this->val_->set(idx, val);
  };
  size_t size() { return this->val_->length();  };
 
  /** Type appropriate push_back methods. Calling the wrong method is
    * undefined behavior. **/
  void push_back(String* val) {
    this->val_->pushBack(val);
  };
  void push_back(double val) {};
  void push_back(bool val) {};
  void push_back(float val) {};
  void push_back(int val) {};
/** returns a hash generated by summing the hash of all the strings in the column */
  size_t hash_me() {
    return this->val_->hash_me();
  }

  bool equals(Object * o) {
    if(o == nullptr) return false;
    DistrbutedStringColumn* other_ic = dynamic_cast<DistrbutedStringColumn*>(o);
    if(other_ic == nullptr) return false;
    if(other_ic->size() != size()) return false;
    StringDistributedArray* other_val_ = dynamic_cast<StringDistributedArray*>(other_ic->val_);
    return this->val_->equals(other_val_);
  }
 
  /** Return the type of this column as a char: 'S', 'B', 'I' and 'F'.*/
  char get_type() { return 'S'; };

  // char* serialize() {
  //   Serializable* sb = new Serializable();
  //   sb->initSerialize("DistrbutedStringColumn");
  //   sb->write("listLength_", listLength_);
  //   sb->write("arraySize_", arraySize_);
  //   sb->write("metaArrayStartSize__", metaArrayStartSize_);
  //   char * seralizedArr = val_->serialize();
  //   sb->write("val_", seralizedArr, false);
  //   sb->endSerialize();
  //   char* value = sb->get();
  //   delete sb;
  //   return value;
  // }
  // static DistrbutedStringColumn* deserialize(char* s) {
  //   size_t arraySize = std::stoi(JSONHelper::getValueFromKey("arraySize_", s)->c_str());
  //   size_t listLength = std::stoi(JSONHelper::getValueFromKey("listLength_", s)->c_str());
  //   String* arr_string = JSONHelper::getValueFromKey("val_", s);
  //   char* arr_cstr = arr_string->c_str();
  //   Array* arr = new Array(arr_cstr);
  //   DistrbutedStringColumn* sc = new DistrbutedStringColumn(arr, listLength);
  //   return sc;
  // }
};